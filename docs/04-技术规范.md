# 婚纱照选片工具 - 技术规范

## 1. 技术栈清单

### 1.1 核心技术

| 层级 | 技术 | 版本 | 用途 |
|------|------|------|------|
| 桌面框架 | Tauri | 2.x | 跨平台桌面应用壳 |
| 前端框架 | React | 18.x | UI 组件构建 |
| 开发语言 | TypeScript | 5.x | 类型安全开发 |
| 构建工具 | Vite | 5.x | 快速开发构建 |
| 后端语言 | Rust | 1.75+ | 系统级操作 |

### 1.2 前端依赖

```json
{
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "@tauri-apps/api": "^2.0.0",
    "zustand": "^4.4.0",
    "framer-motion": "^10.16.0",
    "react-window": "^1.8.9",
    "react-dropzone": "^14.2.0",
    "clsx": "^2.0.0",
    "tailwind-merge": "^2.0.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "@vitejs/plugin-react": "^4.0.0",
    "typescript": "^5.0.0",
    "vite": "^5.0.0",
    "tailwindcss": "^3.3.0",
    "postcss": "^8.4.0",
    "autoprefixer": "^10.4.0",
    "eslint": "^8.0.0",
    "prettier": "^3.0.0"
  }
}
```

### 1.3 Rust 依赖

```toml
[dependencies]
tauri = { version = "2.0", features = [] }
tokio = { version = "1.0", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
image = "0.24"
rexif = "0.7"
walkdir = "2.0"
rayon = "1.8"
```

---

## 2. 项目结构规范

### 2.1 目录结构

```
photo-picker-pro/
├── docs/                       # 项目文档
│   ├── 01-产品需求书.md
│   ├── 02-框架设计书.md
│   ├── 03-原型图设计.md
│   └── 04-技术规范.md
├── src/                        # 前端源码
│   ├── components/            # React 组件
│   ├── hooks/                 # 自定义 Hooks
│   ├── stores/                # Zustand 状态管理
│   ├── services/              # 服务层
│   ├── types/                 # TypeScript 类型
│   ├── utils/                 # 工具函数
│   ├── styles/                # 样式文件
│   └── App.tsx               # 应用入口
├── src-tauri/                  # Tauri/Rust 源码
│   ├── src/
│   │   ├── commands/         # IPC 命令
│   │   ├── services/         # 服务层
│   │   ├── models/           # 数据模型
│   │   ├── utils/            # 工具函数
│   │   └── main.rs           # 入口文件
│   ├── Cargo.toml
│   └── tauri.conf.json
├── public/                     # 静态资源
├── dist/                       # 构建输出
├── package.json
├── tsconfig.json
├── vite.config.ts
├── tailwind.config.js
└── README.md
```

### 2.2 文件命名规范

```
组件文件: PascalCase.tsx
  例: PhotoCard.tsx, CompareView.tsx

Hook 文件: camelCase.ts
  例: usePhotos.ts, useAnimation.ts

工具文件: camelCase.ts
  例: formatDate.ts, imageUtils.ts

样式文件: kebab-case.css
  例: photo-grid.css, animations.css

类型文件: camelCase.ts
  例: photoTypes.ts, groupTypes.ts

测试文件: ComponentName.test.tsx
  例: PhotoCard.test.tsx
```

---

## 3. 代码规范

### 3.1 TypeScript 规范

```typescript
// ✅ 正确: 使用接口定义 Props
interface PhotoCardProps {
  photo: Photo;
  isSelected: boolean;
  onSelect: (id: string) => void;
}

// ❌ 错误: 使用类型别名
// type PhotoCardProps = { ... }

// ✅ 正确: 明确的返回类型
function formatFileSize(bytes: number): string {
  return `${(bytes / 1024 / 1024).toFixed(1)} MB`;
}

// ✅ 正确: 使用枚举
enum PhotoStatus {
  PENDING = 'pending',
  SELECTED = 'selected',
  REJECTED = 'rejected',
}

// ✅ 正确: 可选属性
interface Photo {
  id: string;
  name: string;
  url: string;
  thumbnailUrl?: string;  // 可选
  metadata?: PhotoMetadata;
}
```

### 3.2 React 组件规范

```typescript
// ✅ 正确: 函数组件 + 默认导出
import { memo, useCallback, useState } from 'react';

interface PhotoCardProps {
  photo: Photo;
  isSelected: boolean;
  onSelect: (id: string) => void;
}

export const PhotoCard = memo(function PhotoCard({
  photo,
  isSelected,
  onSelect,
}: PhotoCardProps) {
  const handleClick = useCallback(() => {
    onSelect(photo.id);
  }, [onSelect, photo.id]);

  return (
    <div
      className={cn(
        'photo-card',
        isSelected && 'photo-card--selected'
      )}
      onClick={handleClick}
    >
      <img src={photo.thumbnailUrl} alt={photo.name} />
      <span>{photo.name}</span>
    </div>
  );
});

// ✅ 正确: 使用自定义 Hook 分离逻辑
function usePhotoSelection() {
  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());

  const toggleSelection = useCallback((id: string) => {
    setSelectedIds(prev => {
      const next = new Set(prev);
      if (next.has(id)) {
        next.delete(id);
      } else {
        next.add(id);
      }
      return next;
    });
  }, []);

  return { selectedIds, toggleSelection };
}
```

### 3.3 CSS/Tailwind 规范

```typescript
// ✅ 正确: 使用 clsx + tailwind-merge
import { clsx, type ClassValue } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

// 使用示例
<div className={cn(
  'base-classes',
  isActive && 'active-classes',
  isDisabled && 'disabled-classes'
)} />

// ✅ 正确: 自定义样式使用 CSS 变量
// styles/variables.css
:root {
  --color-primary: #B76E79;
  --color-background: #1A1A1A;
  --spacing-unit: 8px;
}

// ✅ 正确: 动画使用 Framer Motion
import { motion } from 'framer-motion';

<motion.div
  initial={{ opacity: 0, scale: 0.9 }}
  animate={{ opacity: 1, scale: 1 }}
  exit={{ opacity: 0, scale: 0.9 }}
  transition={{ duration: 0.2 }}
/>
```

---

## 4. 状态管理规范

### 4.1 Zustand Store 规范

```typescript
// stores/photoStore.ts
import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer';

interface PhotoState {
  // State
  photos: Map<string, Photo>;
  selectedIds: Set<string>;
  loading: boolean;

  // Actions
  addPhotos: (photos: Photo[]) => void;
  removePhotos: (ids: string[]) => void;
  selectPhoto: (id: string, multi?: boolean) => void;
  clearSelection: () => void;
  movePhotos: (ids: string[], targetGroup: string) => void;
}

export const usePhotoStore = create<PhotoState>()(
  immer((set) => ({
    photos: new Map(),
    selectedIds: new Set(),
    loading: false,

    addPhotos: (photos) =>
      set((state) => {
        photos.forEach((photo) => {
          state.photos.set(photo.id, photo);
        });
      }),

    removePhotos: (ids) =>
      set((state) => {
        ids.forEach((id) => {
          state.photos.delete(id);
          state.selectedIds.delete(id);
        });
      }),

    selectPhoto: (id, multi = false) =>
      set((state) => {
        if (!multi) {
          state.selectedIds.clear();
        }
        if (state.selectedIds.has(id)) {
          state.selectedIds.delete(id);
        } else {
          state.selectedIds.add(id);
        }
      }),

    clearSelection: () =>
      set((state) => {
        state.selectedIds.clear();
      }),

    movePhotos: (ids, targetGroup) =>
      set((state) => {
        ids.forEach((id) => {
          const photo = state.photos.get(id);
          if (photo) {
            photo.groupId = targetGroup;
          }
          state.selectedIds.delete(id);
        });
      }),
  }))
);

// ✅ 正确: 使用选择器优化重渲染
const selectedPhotos = usePhotoStore(
  useCallback(
    (state) =>
      Array.from(state.selectedIds).map((id) => state.photos.get(id)!),
    []
  )
);
```

---

## 5. IPC 通信规范

### 5.1 命令定义

```typescript
// services/tauri/fileService.ts
import { invoke } from '@tauri-apps/api/core';

// 定义命令类型
interface TauriCommands {
  scan_directory: {
    args: { path: string };
    return: PhotoInfo[];
  };
  generate_thumbnail: {
    args: { path: string; size: number };
    return: string; // base64 or path
  };
  export_photos: {
    args: { photoIds: string[]; targetPath: string };
    return: boolean;
  };
}

// 封装调用函数
export async function scanDirectory(path: string): Promise<PhotoInfo[]> {
  return invoke('scan_directory', { path });
}

export async function generateThumbnail(
  path: string,
  size: number = 200
): Promise<string> {
  return invoke('generate_thumbnail', { path, size });
}

export async function exportPhotos(
  photoIds: string[],
  targetPath: string
): Promise<boolean> {
  return invoke('export_photos', { photoIds, targetPath });
}
```

### 5.2 Rust 命令实现

```rust
// src-tauri/src/commands/file_commands.rs
use tauri::command;
use serde::{Deserialize, Serialize};
use crate::services::file_service::FileService;
use crate::models::photo::PhotoInfo;

#[derive(Debug, Serialize, Deserialize)]
pub struct ScanDirectoryArgs {
    path: String,
}

#[command]
pub async fn scan_directory(
    args: ScanDirectoryArgs,
) -> Result<Vec<PhotoInfo>, String> {
    let service = FileService::new();
    service
        .scan_directory(&args.path)
        .await
        .map_err(|e| e.to_string())
}

#[derive(Debug, Serialize, Deserialize)]
pub struct GenerateThumbnailArgs {
    path: String,
    size: u32,
}

#[command]
pub async fn generate_thumbnail(
    args: GenerateThumbnailArgs,
) -> Result<String, String> {
    let service = FileService::new();
    service
        .generate_thumbnail(&args.path, args.size)
        .await
        .map_err(|e| e.to_string())
}
```

---

## 6. 错误处理规范

### 6.1 错误类型定义

```typescript
// types/error.ts
export enum ErrorCode {
  FILE_NOT_FOUND = 'FILE_NOT_FOUND',
  PERMISSION_DENIED = 'PERMISSION_DENIED',
  INVALID_FORMAT = 'INVALID_FORMAT',
  THUMBNAIL_FAILED = 'THUMBNAIL_FAILED',
  IMPORT_INTERRUPTED = 'IMPORT_INTERRUPTED',
  EXPORT_FAILED = 'EXPORT_FAILED',
  STORAGE_FULL = 'STORAGE_FULL',
  UNKNOWN = 'UNKNOWN',
}

export interface AppError {
  code: ErrorCode;
  message: string;
  details?: string;
  recoverable: boolean;
}

export class PhotoPickerError extends Error {
  constructor(
    public code: ErrorCode,
    message: string,
    public recoverable: boolean = true,
    public details?: string
  ) {
    super(message);
    this.name = 'PhotoPickerError';
  }
}
```

### 6.2 错误处理模式

```typescript
// ✅ 正确: 统一的错误处理
async function importPhotos(path: string) {
  try {
    const photos = await scanDirectory(path);
    photoStore.addPhotos(photos);
  } catch (error) {
    if (error instanceof PhotoPickerError) {
      notificationStore.show({
        type: 'error',
        title: '导入失败',
        message: error.message,
        action: error.recoverable
          ? { label: '重试', onClick: () => importPhotos(path) }
          : undefined,
      });
    } else {
      // 未知错误
      logger.error('Unexpected error during import', error);
      notificationStore.show({
        type: 'error',
        title: '发生错误',
        message: '请稍后重试或联系技术支持',
      });
    }
  }
}
```

---

## 7. 性能优化规范

### 7.1 渲染优化

```typescript
// ✅ 正确: 使用 React.memo
export const PhotoCard = memo(function PhotoCard(props: PhotoCardProps) {
  // ...
});

// ✅ 正确: 使用 useMemo 缓存计算
const sortedPhotos = useMemo(() => {
  return photos.sort((a, b) => a.name.localeCompare(b.name));
}, [photos]);

// ✅ 正确: 使用 useCallback 缓存回调
const handleSelect = useCallback((id: string) => {
  selectPhoto(id);
}, [selectPhoto]);

// ✅ 正确: 虚拟列表
import { FixedSizeGrid as Grid } from 'react-window';

<Grid
  columnCount={columnCount}
  rowCount={rowCount}
  columnWidth={160}
  rowHeight={200}
  width={width}
  height={height}
>
  {PhotoCell}
</Grid>
```

### 7.2 图片加载优化

```typescript
// ✅ 正确: 懒加载 + 占位符
function PhotoThumbnail({ photo }: { photo: Photo }) {
  const [loaded, setLoaded] = useState(false);

  return (
    <div className="thumbnail-container">
      {!loaded && <div className="thumbnail-placeholder" />}
      <img
        src={photo.thumbnailUrl}
        alt={photo.name}
        loading="lazy"
        onLoad={() => setLoaded(true)}
        style={{ opacity: loaded ? 1 : 0 }}
      />
    </div>
  );
}

// ✅ 正确: 图片缓存
const imageCache = new Map<string, HTMLImageElement>();

function preloadImage(url: string): Promise<HTMLImageElement> {
  if (imageCache.has(url)) {
    return Promise.resolve(imageCache.get(url)!);
  }

  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      imageCache.set(url, img);
      resolve(img);
    };
    img.onerror = reject;
    img.src = url;
  });
}
```

---

## 8. 测试规范

### 8.1 单元测试

```typescript
// components/PhotoCard.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { PhotoCard } from './PhotoCard';

const mockPhoto = {
  id: '1',
  name: 'test.jpg',
  url: '/test.jpg',
  thumbnailUrl: '/test-thumb.jpg',
};

describe('PhotoCard', () => {
  it('renders photo information', () => {
    render(<PhotoCard photo={mockPhoto} isSelected={false} onSelect={vi.fn()} />);

    expect(screen.getByText('test.jpg')).toBeInTheDocument();
    expect(screen.getByRole('img')).toHaveAttribute('src', '/test-thumb.jpg');
  });

  it('calls onSelect when clicked', () => {
    const onSelect = vi.fn();
    render(<PhotoCard photo={mockPhoto} isSelected={false} onSelect={onSelect} />);

    fireEvent.click(screen.getByRole('button'));
    expect(onSelect).toHaveBeenCalledWith('1');
  });

  it('shows selected state', () => {
    render(<PhotoCard photo={mockPhoto} isSelected={true} onSelect={vi.fn()} />);

    expect(screen.getByRole('button')).toHaveClass('photo-card--selected');
  });
});
```

### 8.2 集成测试

```typescript
// tests/import.test.ts
import { test, expect } from '@playwright/test';

test('user can import photos from folder', async ({ page }) => {
  await page.goto('/');

  // 拖拽文件夹导入
  const dropZone = page.locator('[data-testid="drop-zone"]');
  await dropZone.dragTo(page.locator('body'));

  // 等待导入完成
  await expect(page.locator('[data-testid="photo-grid"]')).toBeVisible();
  await expect(page.locator('[data-testid="photo-card"]')).toHaveCount(10);
});
```

---

## 9. Git 提交规范

### 9.1 提交信息格式

```
<type>(<scope>): <subject>

<body>

<footer>
```

### 9.2 类型说明

| 类型 | 说明 |
|------|------|
| feat | 新功能 |
| fix | 修复 bug |
| docs | 文档更新 |
| style | 代码格式调整（不影响功能）|
| refactor | 重构 |
| perf | 性能优化 |
| test | 测试相关 |
| chore | 构建/工具链相关 |

### 9.3 示例

```bash
feat(photo): add drag-to-move animation

- Implement smooth animation when moving photos between groups
- Use Framer Motion for consistent animation timing
- Add visual feedback during drag operation

fix(import): handle invalid image formats gracefully

docs(readme): update installation instructions
```

---

## 10. 构建与部署

### 10.1 开发环境

```bash
# 安装依赖
npm install

# 安装 Rust 依赖
cd src-tauri && cargo build

# 启动开发服务器
npm run tauri dev
```

### 10.2 生产构建

```bash
# 构建前端
npm run build

# 构建桌面应用
npm run tauri build

# 输出目录
src-tauri/target/release/bundle/
├── dmg/          # macOS DMG
├── msi/          # Windows MSI
└── appimage/     # Linux AppImage
```

### 10.3 版本管理

```json
{
  "version": "1.0.0",
  "semantic": {
    "major": 1,  // 破坏性变更
    "minor": 0,  // 新功能
    "patch": 0   // Bug 修复
  }
}
```

---

**文档版本**: v1.0
**创建日期**: 2026-01-28
**最后更新**: 2026-01-28
